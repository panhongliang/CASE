安装：
rabbit依赖于erlang,首先要安装erlang的yum源
rpm -Uvh http://packages.erlang-solutions.com/erlang-solutions-1.0-1.noarch.rpm
rpm --import https://packages.erlang-solutions.com/rpm/erlang_solutions.asc
然后安装rabbitmq
yum install  rabbitmq-server-3.6.6-1.el7.noarch.rpm

远程连接rabbitmq:
在地用户用系统默认的用户guest连接，远程用户需要自己创建用户。
新建立了一个用户root密码root，然后授予所有权限，使用下面的命令：
rabbitmqctl add_user root root
rabbitmqctl set_user_tags root administrator
rabbitmqctl set_permissions -p / root ".*" ".*" ".*"

rabbitmq角色：
    A producer is a user application that sends messages.

    A queue is a buffer that stores messages.
        temporary queue：（临时队列，每次连接到rabbitmq都会是一个全新的列队，断开时自动删除）
            Firstly, whenever we connect to Rabbit we need a fresh, empty queue.
            To do this we could create a queue with a random name, or,
            even better - let the server choose a random queue name for us.
            Secondly, once we disconnect the consumer the queue should be automatically deleted.
    A consumer is a user application that receives messages.

    An exchange  On one side it receives messages from producers and the other side it pushes them to queues.
    The exchange must know exactly what to do with a message it receives.
    Should it be appended to a particular queue?
    Should it be appended to many queues?
    Or should it get discarded. The rules for that are defined by the exchange type.
exchange的种类：
     direct：特定binding key的消息进入特定binding key的队列。
     topic:特定的top消息进入定的binding key的列队，消息格式：单词1.单词2.单词3...
             * 代表一个单词.
             # 代表多个单词.

     headers
     fanout：广播，消息进入所有队列，it just broadcasts all the messages it receives to all the queues it knows




队列模式时：
所有的receive会依次收到消息。rabbitmq以轮循的方式给receive发消息，各receive收到的消息不同。
Publish/Subscribe 模式时：
所有client都会收到订阅的消息